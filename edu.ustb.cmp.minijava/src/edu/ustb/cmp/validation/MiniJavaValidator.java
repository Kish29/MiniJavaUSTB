/*
 * generated by Xtext 2.25.0
 */
package edu.ustb.cmp.validation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;

import org.eclipse.xtext.validation.Check;

import edu.ustb.cmp.miniJava.ClassDecl;
import edu.ustb.cmp.miniJava.Expression;
import edu.ustb.cmp.miniJava.MainClassDecl;
import edu.ustb.cmp.miniJava.Member;
import edu.ustb.cmp.miniJava.MethodDecl;
import edu.ustb.cmp.miniJava.MiniJava;
import edu.ustb.cmp.miniJava.MiniJavaPackage;
import edu.ustb.cmp.miniJava.ReturnStatements;
import edu.ustb.cmp.miniJava.Statement;
import edu.ustb.cmp.miniJava.VariableDecl;

/**
 * This class contains custom validation rules.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class MiniJavaValidator extends AbstractMiniJavaValidator {

	// 类循环继承
	public static final String ERR_LOOP_SUPER = "LoopSuperClass";
	// 返回值检查
	public static final String ERR_NO_RET = "WithNoReturnStatement";
	public static final String ERR_RET_TYPE = "WrongReturnType";
	// 类重复声明
	public static final String ERR_DUPLICATE_CLASS_DECL = "DuplicateClassDeclare";
	// 类成员变量重复性检查
	public static final String ERR_DUPLICATE_FIELD = "DuplicateVariableDeclare";
	// 类成员函数重复性检查
	public static final String ERR_DUPLICATE_FUNC = "DuplicateFuncDeclare";
	// 赋值类型检查
	public static final String ERR_ASSIGNMENT_TYPE = "WrongTypeAssignment";

	private static final String INT_PATTERN = "^(-)?[1-9]\\d{0,9}$";
	private static final Pattern INT_PATTER = Pattern.compile(INT_PATTERN);
	private static final String LONG_PATTERN = "^(-)?[1-9]\\d{0,18}$";
	private static final Pattern LONG_PATTER = Pattern.compile(LONG_PATTERN);
	private static final String DOUBLE_PATTERN = "^(-)?[1-9]\\d{0,9}(\\.)\\d{1,9}$";
	private static final Pattern DOUBLE_PATTER = Pattern.compile(DOUBLE_PATTERN);;

	// 保存单个mj文件的所有类名
	private Set<String> classNames = new HashSet();

	// 重复父类名称检查
	@Check
	public void checkLoopSuperErr(ClassDecl classDecl) {
		if (classDecl != null) {
			final String superClasssName = classDecl.getSuperClass().getName();
			if (classDecl.getName().equals(superClasssName)) {
				error(ERR_LOOP_SUPER + " with " + classDecl.getName(), MiniJavaPackage.eINSTANCE.getClassDecl_Name(),
						ERR_LOOP_SUPER);
			}
		}

	}

	// 返回值检查
	@Check
	public void checkReturnValidation(MethodDecl methodDecl) {
		// 只有当返回值不是void时检查
		if (methodDecl != null && !methodDecl.getRetType().equals("void")) {
			var stats = methodDecl.getStatements();
			boolean hasRet = false;
			ReturnStatements ret = null;
			for (int i = 0; i < stats.size(); i++) {
				if (stats.get(i).getRetStat() != null) {
					ret = stats.get(i).getRetStat();
					hasRet = true;
				}
			}
			// 如果没有return语句
			if (!hasRet) {
				error(ERR_NO_RET + "with" + methodDecl.getName(), null, ERR_NO_RET);
			} else { // 如果有，检查返回值类型是否匹配
				if (ret != null) {
					Expression exp = ret.getExp();
					if (exp.getConst() != null) {
						switch (methodDecl.getRetType()) {
						case "int":
							if (!exp.getConst().equals("0") && !INT_PATTER.matcher(exp.getConst()).matches()) {
								error(ERR_RET_TYPE + " with return type " + exp.getConst() + " in method "
										+ methodDecl.getName(), null, ERR_RET_TYPE);
							}
							break;
						case "long":
							if (!exp.getConst().equals("0") && !LONG_PATTER.matcher(exp.getConst()).matches()) {
								error(ERR_RET_TYPE + " with return type " + exp.getConst() + " in method "
										+ methodDecl.getName(), null, ERR_RET_TYPE);
							}
							break;
						case "double":
							if (!exp.getConst().equals("0.0") && !DOUBLE_PATTER.matcher(exp.getConst()).matches()) {
								error(ERR_RET_TYPE + " with return type " + exp.getConst() + " in method "
										+ methodDecl.getName(), null, ERR_RET_TYPE);
							}
						default:
							break;
						}
					}
				}
			}
		}
	}

	// 类重复检查
	@Check
	public void checkDuplicateClassDeclare(MiniJava miniJava) {
		var allClasses = miniJava.getClasses();
		HashMap<String, Integer> recorder = new HashMap<>();
		for (int i = 0; i < allClasses.size(); i++) {
			String name = allClasses.get(i).getName();
			if (recorder.get(name) != null) {
				error(ERR_DUPLICATE_CLASS_DECL + " with " + name, null, ERR_DUPLICATE_CLASS_DECL);
				recorder.put(name, recorder.get(name) + 1);
			} else {
				recorder.put(name, 1);
			}
		}
	}

	@Check
	public void checkAssignmentInMainFunc(MainClassDecl mainClass) {
		// 主方法体内的赋值检查
		var statsInMainFunc = mainClass.getStatements();
		ArrayList<VariableDecl> variableState = new ArrayList<VariableDecl>();
		for (Statement s : statsInMainFunc) {
			if (s instanceof VariableDecl) {
				variableState.add((VariableDecl) s);
			}
		}
		checkAssignmentType(variableState, null);
	}

	// 类成员重复性检查
	@Check
	public void checkDuplicateMemberDeclare(ClassDecl classDecl) {
		List<VariableDecl> variables = new ArrayList<>();
		List<MethodDecl> methods = new ArrayList<>();
		for (Member m : classDecl.getMembers()) {
			if (m instanceof VariableDecl) {
				variables.add((VariableDecl) m);
			} else if (m instanceof MethodDecl) {
				methods.add((MethodDecl) m);
			}
		}
		try {
			checkDuplicateVariableDeclare((ArrayList<VariableDecl>) variables);
			checkDuplicateMethodDeclare((ArrayList<MethodDecl>) methods);
			checkAssignmentType((ArrayList<VariableDecl>) variables, (ArrayList<MethodDecl>) methods);
		} catch (ClassCastException e) {
			e.printStackTrace();
		}
	}

	// 赋值类型检查
	private void checkAssignmentType(ArrayList<VariableDecl> variables, ArrayList<MethodDecl> methods) {
		// 其他类中的赋值检查
		ArrayList<VariableDecl> variableState = new ArrayList<VariableDecl>(variables);
		if (methods != null && !methods.isEmpty()) {
			for (MethodDecl m : methods) {
				for (Statement s : m.getStatements()) {
					if (s instanceof VariableDecl) {
						variableState.add((VariableDecl) s);
					}
				}
			}
		}
		checkAssignmentTypeActual(variableState);
	}

	private void checkAssignmentTypeActual(ArrayList<VariableDecl> variables) {
		for (VariableDecl v : variables) {
			boolean wrongAssignment = false;
			switch (v.getVarType()) {
			case "int":
				if (!INT_PATTER.matcher(v.getValue()).matches()) {
					wrongAssignment = true;
				}
				break;
			case "char":
				if (v.getValue().length() > 1) {
					wrongAssignment = true;
				}
				break;
			case "boolean":
				if (!v.getValue().equals("true") && !v.getValue().equals("false")) {
					wrongAssignment = true;
				}
				break;
			case "double":
				if (!DOUBLE_PATTER.matcher(v.getValue()).matches()) {
					wrongAssignment = true;
				}
				break;
			case "long":
				if (!LONG_PATTER.matcher(v.getValue()).matches()) {
					wrongAssignment = true;
				}
				break;
			default:
				wrongAssignment = true;
				break;
			}
			if (wrongAssignment) {
				error(ERR_ASSIGNMENT_TYPE + " with " + v.getName(), null, ERR_ASSIGNMENT_TYPE);
			}
		}
	}

	// 变量名重复
	private void checkDuplicateVariableDeclare(ArrayList<VariableDecl> variables) {
		HashMap<String, Integer> recorder = new HashMap<>();
		for (VariableDecl v : variables) {
			var fName = v.getName();
			if (recorder.get(fName) != null) {
				error(ERR_DUPLICATE_FIELD + " with " + fName, null, ERR_DUPLICATE_FIELD);
				recorder.put(fName, recorder.get(fName) + 1);
			} else {
				recorder.put(fName, 0);
			}
		}
	}

	// 方法体重复
	private void checkDuplicateMethodDeclare(ArrayList<MethodDecl> methods) {
		HashMap<String, List<Integer>> recorder = new HashMap<>();
		for (MethodDecl m : methods) {
			var fName = m.getName();
			// 名字重复
			if (recorder.get(fName) != null) {
				// 参数检查
				boolean hasSame = false;
				int thisHash = m.getParams().hashCode();
				for (int hash : recorder.get(fName)) {
					if (thisHash == hash) {
						error(ERR_DUPLICATE_FUNC + " with " + fName, null, ERR_DUPLICATE_FUNC);
						hasSame = true;
					}
				}
				// 没有参数一样的，放入一个新的参数散列值
				if (!hasSame) {
					recorder.get(fName).add(thisHash);
				}
			} else {
				List<Integer> methodHash = new ArrayList<>();
				methodHash.add(m.getParams().hashCode());
				recorder.put(fName, methodHash);
			}
		}
	}

}
